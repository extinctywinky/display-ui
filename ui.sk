# Use structs to store data about the ui items
# Store the structs in a list for the UI


struct ui:
    id: string
    location: location
    row_size: int
    rows: int 


struct ui_item:  
    parent: string # UI
    hitbox: entity
    item_display: entity
    item: item

function ui(id: string, loc: location, row_size: int, rows: int):
    set {_loc} to middle of {_loc}

    set {_ui} to a ui struct
    set {_ui}'s id field to {_id}
    set {_ui}'s location field to {_loc}
    set {_ui}'s row_size field to {_row_size}
    set {_ui}'s rows field to {_rows} # Implement later

    set {ui::%{_id}%} to {_ui}


function add_item(i: item, id: string):
    set {_loc} to get_next_loc({_id}, 0.3)
    spawn an interaction at {_loc}:
        set {_hitbox} to entity

    spawn an item display at {_loc}:
        set {_d} to entity
        set display item of {_d} to {_i}
        set display translation of {_d} to vector(0,0.5,0)
        make {_d} ride {_hitbox}

    # Test configuration functions
    hover_size({_hitbox}, 1.5)
    hover_glow({_hitbox}, true)

    # Store the information in a struct within the UI
    set {_struct} to a ui_item struct

    set {_struct}'s parent field to {_id}
    set {_struct}'s hitbox field to {_hitbox}
    set {_struct}'s item_display field to {_d}
    set {_struct}'s item field to {_i}

    add {_struct} to {ui::%{_id}%::items::*} 


# Get the next slot location
function get_next_loc(id: string, spacing: number=0.3) :: location:
    set {_ui} to {ui::%{_id}%}
    set {_loc} to {_ui}'s location field
    set {_row_size} to {_ui}'s row_size field
    set {_spacing} to 1 + {_spacing}

    set {_current_slot} to size of {ui::%{_id}%::items::*}

    set {_x} to 0
    set {_y} to 0

    loop {_current_slot} times:
        set {_i} to loop-iteration
        add {_spacing} to {_x}
        if mod({_i}, {_row_size}) = 0:
            subtract {_spacing} from {_y}
            set {_x} to 0 
   
    return {_loc} ~ vector({_x}, {_y}, 0)



